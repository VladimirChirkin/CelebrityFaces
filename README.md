# CelebrityFaces
Проект сайта "на какую знаменитость ты похож".
Составные части проекта следующие:
1. Интерфейс для взаимодействия с пользователем, позволяющий загрузить фотографию, выделить на ней лицо, а также отобразить результат, наиболее схожие фотографии из датасета с лицами знаменитостей.

2. Алгоритм, получающий на вход изображение лица и формирующий векторное представление этого лица. Векторное представление должно удовлетворять следующему критерию. Более похожие лица должны быть более близкими с точки зрения косинусного расстояния.

3. Алгоритм, получающий на вход некоторый вектор, и осуществляющий поиск наиболее близких векторов среди векторов, полученных из лиц знаменитостей. Результат работы - порядковые номера наиболее близких изображнеий в базе.

Все три части реализованы отдельными микросервисами с использованием flask, python3.

Первая часть написана целиком на python3, использует flask для пользовательского интерфейса, opencv для выделения лица из загруженного изображения. Также этот сервис имеет доступ к базе с изображениями, выдавая пользователю изображения по поученному номеру. Для задачи была использована база CelebA, которая содержит порядка 200000 изобразений порядка 10000 различных людей.

Вторая часть реализована при помощи нейронной сети, обученной на изображениях лиц. В итоге было использовано два варианта алгоритма, отличающихся нейронной сетью. Первый вариант - предобученная на изображениях лиц сеть вот из этого проекта: https://github.com/davidsandberg/facenet. Второй вариант - самостоятельно обученная сеть на базе CelebA. Сеть обучалась несколькими способами. К датасету CelebA прилагается разметка по сорока бинарным признакам в стиле наличие/отсутствие бороды, очков, и так далее. Нейронная сеть обучалась на multilabel классификацию по этим признакам. В качестве векторного представления использовался выход предпоследнего слоя сети. Код есть в файле model_classif.ipynb. В целом модель построенная таким образом работает достаточно адекватно. Мужчины оказываются близко к мужчинам, женщины к женщинам. Недостатком такого подхода является слишком более "внимательное" отношение этой модели к признакам. То есть если человек например отрастит бороду, то с точки зрения модели он будет очень далек от себя без бороды. Хотелось бы сделать так, чтобы модель обращала больше внимания на черты лица. Второй вариант модели (model_triplet.ipynb) должен был исправить эту ситуацию. Сеть обучалась с использованием triplet margin loss и меток идентичности. Соответственно при такой функции потерь, сеть пытается сделать фотографии одного человека ближе друг к другу, чем к фотографиям других людей. Результаты такого подхода получились на вид хуже, чем в первом. То есть сеть отлавливала ккие-то тонкие черты лица, но похожесть уловить сложно, с точки зрения формальных признаков фотографии сильно отличались. В результате третья версия модели была обучена на классификацию, а потом еще настраивалась некоторое время на метки идентичности. В итоге эта модель вошла в реализацию. Были идеи измерить качество работы различных сетей с использованием меток идентичности. Так, выбрав один из векторов, можно отсортировать все эмбеддинги по расстоянию до него и вычислить значение метрики ndcg, посчитав релевантными объекты с такой же меткой. Можно усреднить значения ndcg для некоторого случайного подмножества объектов. Результат этого эксперимента описан в model_comparison.ipynb. Реализуем возможность переключаться с одной сети на другую прямо через ползовательский интерфейс, чтобы можно было посмотреть, как разные сети работают.


Для третей части написан алгоритм приближенного поиска ближайших соседей annoy. Алгоритм написан следующим образом. Рекурсивно, делением пространства случайными гиперплоскостями строятся деревья. Деление продолжается до тех пор, пока в ноде будет не более заданного числа объектов(параметр алгоритма). Случайные гиперплоскости выбираются так: выбираются два объекта из попавших в ноду. Плоскость - это множество точек на равном расстоянии от объектов. Таким образом, плоскость задается двумя интами(индексами объектов). Таких деревьев создается несколько(параметр). Поиск происходит следующим образом. Корни деревьев скалдываются в кучу, потом из кучи извлекается нода, ее потомки складываются в кучу. Если очередная нода листовая, то объекты из нее складываются в множество. В качестве приоритета для кучи - расстояние от объекта до плоскости, заданной в ноде. Расстояние умножено на знак в зависимости от стороны, с которой находится объект. Мы извлекаем ноды до тех пор, пока не наберем нужное число объектов в ноде(третий параметр). При использовании кучи, мы работаем в первую очередь с деревьями, которые дальше отделяют от искомого объекта. Когда ноды с положительным отступом заканчиваются, мы можем рассмотреть ноды с отрицательным отступом (те, от которых мы отделили плоскостями). При этом в певую очередь будут рассмотрены те, которые отделились ближе всего к объекту.

Реализация находится в директории myannoy. Алгоритм написан на c++, также написана обертка для него на cython. В файле research.ipynb можно найти некоторые эксперименты с этой реализацией. У алгоритма есть некоторые гиперпараметры, которые стоит подобрать, исходя из задачи. В зависимости от них алгоритм может работать быстрее(в ущерб качеству поиска). Описание алгоритма, параметров, экспериментов можно также найти в research.ipynb. В целом алгоритм можно настроить так, чтобы он работал в десятки раз быстрее реализованного на numpy точного поиска ближайших соседей. В данной задаче от нас требуется искать только одного ближайшего соседа. В такой ситуации алгоритм работает лучше.

Были попытки построить "среднее" изображение между загруженной и найденной фотографией. Для этого использовалась та же сеть, с помощью которой получались эмбеддинги, самостоятельно обученный вариант на pytorch. Эксперимент проводился следующим образом. Мы брали два эмбеддинга и находили между ними среднее. Потом берется исходное фото и пропускается через сеть, считается средний квадрат отклонения эмбеддинга от среднего, применяется шаг оптимизации к весам изображения. В целом такие действия обычно приводили к сильному зашумлению изображения, хотя пару раз мне показалось, что действительно черты лица приобретают более похожий на вторую фотографию вид, но при таком уровне зашумления сложно это утверждать. Были попытки сглаживать изображение раз в несколько итераций, но это приводило к тому, что лосс переставал падать и изображение сливалось в монотонную серую картинку.

Работающий сервис можно увидеть здесь: 95.213.170.235:5000
Или здесь: 46.39.40.37:5000
