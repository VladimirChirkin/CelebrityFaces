# CelebrityFaces
Проект сайта "на какую знаменитость ты похож".
Составные части проекта следующие:
1. Интерфейс для взаимодействия с пользователем, позволяющий загрузить фотографию, выделить на ней лицо, а также отобразить результат, наиболее схожие фотографии из датасета с лицами знаменитостей.

2. Алгоритм, получающий на вход изображение лица и формирующий векторное представление этого лица. Векторное представление должно удовлетворять следующему критерию. Более похожие лица должны быть более близкими с точки зрения косинусного расстояния.

3. Алгоритм, получающий на вход некоторый вектор, и осуществляющий поиск наиболее лизких векторов среди векторов, полученных из лиц знаменитостей. Результат работы - порядковые номера наиболее близких изображнеий в базе.

Все три части реализованы отдельными микросервисами с использованием flask, python3.

Первая часть написана целиком на python3, использует flask для пользовательского интерфейса, opencv для выделения лица из загруженного изображения. Также этот сервис имеет доступ к базе с изображениями, выдавая пользователю изображения по поученному номеру. Для задачи была использована база CelebA, которая содержит порядка 200000 изобразений порядка 10000 различных людей.

Вторая часть реализована при помощи нейронной сети, обученной на изображениях лиц. В итоге было использовано два варианта алгоритма, отличающихся нейронной сетью. Первый вариант - предобученная на изображениях лиц сеть вот из этого проекта: https://github.com/davidsandberg/facenet. Второй вариант - самостоятельно обученная сеть на базе CelebA. Сеть обучалась несколькими способами. К датасету CelebA прилагается разметка по сорока бинарным признакам в стиле наличие/отсутствие бороды, очков, и так далее. Нейронная сеть обучалась на multilabel классификацию по этим признакам. В качестве векторного представления использовался выход предпоследнего слоя сети. Код есть в файле model_classif.ipynb. В целом модель построенная таким образом работает достаточно адекватно. Мужчины оказываются близко к мужчинам, женщины к женщинам. Недостатком такого подхода является слишком более "внимательное" отношение этой модели к признакам. То есть если человек например отрастит бороду, то с точки зрения модели он будет очень далек от себя без бороды. Хотелось бы сделать так, чтобы модель обращала больше внимания на черты лица. Второй вариант модели (model_triplet.ipynb) должен был исправить эту ситуацию. Сеть обучалась с использованием triplet margin loss и меток идентичности. Соответственно при такой функции потерь, сеть пытается сделать фотографии одного человека ближе друг к другу, чем к фотографиям других людей. Результаты такого подхода получились на вид хуже, чем в первом. То есть сеть отлавливала ккие-то тонкие черты лица, но похожесть уловить сложно, с точки зрения формальных признаков фотографии сильно отличались. В результате третья версия модели была обучена на классификацию, а потом еще настраивалась некоторое время на метки идентичности. В итоге эта модель вошла в реализацию. Были идеи измерить качество работы различных сетей с использованием меток идентичности. Так, выбрав один из векторов, можно отсортировать все эмбеддинги по расстоянию до него и вычислить значение метрики ndcg, посчитав релевантными объекты с такой же меткой. Можно усреднить значения ndcg для некоторого случайного подмножества объектов. Результат этого эксперимента описан в model_comparison.ipynb. 


Для третей части написан алгоритм приближенного поиска ближайших соседей. Реализация находится в директории myannoy. Алгоритм написан на c++, также написана обертка для него на cython. В файле research.ipynb можно найти некоторые эксперименты с этой реализацией. У алгоритма есть некоторые гиперпараметры, которые стоит подобрать, исходя из задачи. В зависимости от них алгоритм может работать быстрее(в ущерб качеству поиска). Описание алгоритма, параметров, экспериментов можно также найти в research.ipynb. В целом алгоритм можно настроить так, чтобы он работал в десятки раз быстрее реализованного на numpy точного поиска ближайших соседей. В данной задаче от нас требуется искать только одного ближайшего соседа. В такой ситуации алгоритм работает лучше.
